## P0-F01 — ORCHESTRATOR (integration facade)
status: META
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ORCHESTRATOR
priority: H
labels: [orchestrator, integration, demo]
rationale: The orchestrator persona coordinates application personas and external services (AI, IPFS, blockchain) to deliver a cohesive runtime experience.
acceptance:
  - The orchestrator exposes lifecycle APIs that bind Director, Configurator, Actor, Coordinator, Moderator, and any external service facades (AI guidance, NFT/backbone, IPFS storage).
  - AI guidance hooks include an Ollama (or configured model) integration that exchanges deterministic layout blueprint prompts/responses, captures declared theme/strategy/intent metadata, and retries when downstream solvers reject the plan.
  - Strategic themes returned from the AI layer are preserved as structured directives (goal statements, faction intents, preferred actor archetypes) and forwarded to the Director/Configurator bridge so downstream personas can assemble matching AIU loadouts.
  - The orchestrator brokers AIU registry data, shard inventories, and budget state between director and configurator so AI responses can reference valid templates and costs, and it packages external “capabilities” (e.g., NFT shards representing enhanced vitals) into the same structured envelopes so the director can apply them without leaving the simulation domain.
  - Scenario planning begins with a deterministic handshake: the orchestrator delivers the capability envelope (theme, registry snapshots, shard inventory, budgets), the director responds with a validated blueprint/loadout plan, and both parties record the handshake so subsequent escalation triggers can be audited.
  - Per tick, the orchestrator drives personas through the agreed ordering (Director → Configurator → Coordinator → Actor → Moderator) while capturing telemetry for demonstration and audit.
  - Orchestrator contracts include hooks for IPFS uploads (e.g., writing finalized telemetry bundles), NFT interactions (e.g., provisioning/consuming blockchain state such as regeneration shards), and AI requests, even if MVP stubs them with deterministic placeholders; it is explicitly responsible for the “security of truth” by persisting authoritative telemetry/artifacts to external storage when configured.
  - When AI planning support is unavailable or rejected, the orchestrator triggers the director’s deterministic fallback plan (baseline layout, default actor loadouts) and records the downgrade in the capability envelope so downstream personas know higher-order assistance was not applied.
  - When the director escalates back to the orchestrator (e.g., to request new capabilities or refreshed budgets), the orchestrator records the trigger, the refreshed envelope delivered, and any external side effects (blockchain transactions, IPFS writes) before resuming simulation time.
verification:
  - design review confirms orchestrator lifecycle diagrams show how internal personas and external adapters interoperate.
traces:
  code: []

## P0-F02 — ORCHESTRATOR DEMO RUN (minimum viable walkthrough)
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ORCHESTRATOR.DEMO
priority: H
labels: [orchestrator, demo, sequencing]
rationale: For the MVP, the orchestrator must run a deterministic multi-tick scenario showcasing Director hints, Configurator dispatch, Coordinator resolution, Actor movement, and Moderator telemetry.
acceptance:
  - The orchestrator provides an API (or harness) that initializes personas, runs at least two ticks through `coordinator_lifecycle_process`, and returns the moderator summaries plus final map/actor positions.
  - The demo run records the Director directives used, the dispatch tiers selected (AIU, logic, instinct), and the resulting actor positions in a machine-readable artifact (e.g., JSON) suitable for presentation.
  - The orchestrator bootstraps the default AIU registry (random walk, explore, find_exit, defend_exit, patrol_corridor, cultivation), applies module prerequisites/budgets, and forwards them to the configurator before provisioning actors.
  - Telemetry emitted each tick includes solver verdict codes and AIU metadata (module ids, active modes such as cultivation/patrol, cultivation counters, vulnerability windows) for every actor so downstream tools can visualise behaviour shifts.
  - Errors from external stubs (AI/IPFS/NFT) surface deterministic fallback messages so the MVP can run without live integrations.
  - The demo output demonstrates autonomous behaviour: at least one tick must show actors selecting different moves (or waiting) because their local evaluation differs, even when they receive the same high-level directive.
verification:
  - integration: invoking the orchestrator demo API produces telemetry logs containing the ordered tick summaries and actor state transitions.
traces:
  code: [apps/orchestrator/src/index.js]
  tests: [apps/orchestrator/tests/telemetryEnrichment.test.ts, apps/orchestrator/tests/telemetrySchemas.test.ts]

## P0-F03 — ORCHESTRATOR DEMO UI (ASCII visualization)
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ORCHESTRATOR.DEMO
priority: H
labels: [demo, ui, telemetry]
rationale: The MVP demonstration should be visually engaging and self-explanatory so stakeholders can observe the simulation without digging into raw logs.
acceptance:
  - The orchestrator demo renders a simple ASCII viewport showing the extent of the active surface—including irregular or organic boundaries—obstacles, and at least three ambulatory actors simultaneously.
  - Internal barrier actors are rendered with a distinct glyph or annotation so observers can distinguish them from ambulatory agents.
  - Each tick updates the ASCII display to reflect moves (current positions, intentions/tier markers if space allows) and prints aligned telemetry (tick header, director directive used, movement outcomes) directly beneath the surface visualization.
  - Log output remains deterministic and fits within standard terminal dimensions (80x24) so the demo can run in CI or terminal recordings.
verification:
  - integration: running the demo harness produces an ASCII timeline illustrating actor movement over multiple ticks and accompanying telemetry lines per tick.
traces:
  code: []

## P0-F04 — ORCHESTRATOR GUI (interactive telemetry viewer)
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ORCHESTRATOR.UI
priority: M
labels: [gui, playback, telemetry, visualization]
rationale: Stakeholders need an intuitive graphical interface to inspect simulation runs, control playback, and drill into actor telemetry without parsing raw text output.
acceptance:
  - The orchestrator exposes a graphical UI that renders the current surface layout—including non-rectilinear, organic shapes—obstacles, and actor positions using a canvas or DOM-based visualization updated each tick.
  - The viewport differentiates ambulatory actors and internal barriers via styling, legends, or annotations while keeping selection affordances consistent.
  - Playback controls include play/pause, stop/reset, single-step forward, and single-step backward; controls remain responsive while the simulation is running or paused.
  - An actor selection mechanism (e.g., clicking on an actor or choosing from a list) highlights the actor on the surface visualization and presents its current telemetry: position, intent vector, dispatch tier/outcome, and resource vitals (at minimum stamina and mana) for the active tick.
  - The UI consumes the same telemetry produced by the orchestrator demo runner (local JSON stream or in-memory bridge) so that recorded runs and live runs share the interface.
  - Layout adapts to common desktop resolutions (minimum 1280×720) and remains legible in light/dark themes, with accessible color contrast for actor highlighting.
verification:
  - integration: launching the GUI with a demo run allows a reviewer to play, pause, step through ticks, select actors, and observe the telemetry panel updating in sync with the visualization.
traces:
  code: []
