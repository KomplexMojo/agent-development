## P1-F01 — INTROSPECTION (resource awareness)
status: META
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.SELF
priority: H
labels: [introspection, self-awareness]
rationale: The actor must expose its core resource pillars so other domains can reason about capability and cost.
acceptance:
  - The actor maintains self-state for each resource pillar (Stamina, Durability, Health, Mana) with current, max, and regen values.
  - The actor clearly distinguishes static items from mobile actors via these resource configurations.
  - Resource profiles convey occupancy semantics: static walkable tiles expose Durability (D_C/D_M/D_R) as ∞ while Stamina, Health, and Mana triples remain 0; blocking entities expose finite Durability and non-zero resource ranges.
verification:
  - unit: reading self-state returns expected resource records for static and mobile archetypes.
traces:
  code: [apps/simulation/assembly/actor/actor.ts]

## P1-F01_1 — resource snapshot: stamina
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.SELF
priority: H
labels: [introspection, stamina]
rationale: Movement logic depends on stamina availability.
acceptance:
  - The actor tracks Stamina current (S_C), max (S_M), and tick regen (S_R).
  - Static items report S_M = S_C = S_R = 0. Mobile actors report finite S_M, S_C within [0, S_M], and S_R within a finite range.
verification:
  - unit: static and mobile initializations expose the expected stamina triple through introspection getters.
traces:
  code: [apps/simulation/assembly/actor/actor.ts]

## P1-F01_2 — resource snapshot: durability
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.SELF
priority: H
labels: [introspection, durability]
rationale: Durability represents structural integrity for obstacles and actors.
acceptance:
  - The actor tracks Durability current (D_C), max (D_M), and tick regen (D_R).
  - Static items report D_M = D_C = D_R = ∞ (or a sentinel representing an unbreakable state). Mobile actors report finite, non-zero values.
verification:
  - unit: introspection exposes durability values consistent with static vs. mobile presets.
traces:
  code: [apps/simulation/assembly/actor/actor.ts]

## P1-F01_3 — resource snapshot: health
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.SELF
priority: H
labels: [introspection, health]
rationale: Combat and survival systems require access to health data.
acceptance:
  - The actor tracks Health current (H_C), max (H_M), and tick regen (H_R).
  - Static items report H_M = H_C = H_R = 0. Mobile actors report finite, non-zero values with H_C within [0, H_M].
verification:
  - unit: introspection exposes health triples per classification.
traces:
  code: [apps/simulation/assembly/actor/actor.ts]

## P1-F01_4 — resource snapshot: mana
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.SELF
priority: H
labels: [introspection, mana]
rationale: Magical or energy-based behaviours require mana availability.
acceptance:
  - The actor tracks Mana current (MN_C), max (MN_M), and tick regen (MN_R).
  - Static items report MN_M = MN_C = MN_R = 0. Mobile actors report finite, non-zero values within defined ranges.
verification:
  - unit: introspection exposes mana values matching the configured archetype.
traces:
  code: [apps/simulation/assembly/actor/actor.ts]

## P1-F01_5 — understanding of location and surrounding
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.SELF
priority: H
labels: [introspection, mana]
rationale: Actors need to have an up to date understanding of if other actors are surrounding them.
acceptance:
  - The actor, through interrogation and observation maintains a model of what other actors are sourounding them.
  - The model is maintained for the current 2 dimensional plane It does not have information of different levels.
verification:
  - unit: actor populates and maintains a environmental awareness model by interogating its surroundings
traces:
  code: [apps/simulation/assembly/actor/actor.ts]

## P1-F01_6 — stable actor identity
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.SELF
priority: H
labels: [introspection, identity]
rationale: Other domains need a durable identifier to correlate events and traces for the same actor instance.
acceptance:
  - When an actor context is first introspected, the actor derives a deterministic, non-zero identity value from its lifecycle handle.
  - The identity remains stable across ticks and lifecycle re-initialisations for the same handle; repeated calls return the same value until the actor is destroyed.
  - The identity getter is available to other domains so observations, emissions, and control surfaces can reference the correct actor.
verification:
  - unit: create an actor, read its identity before and after lifecycle init/step, destroy and create a new actor, and confirm identities remain stable per handle and unique across handles.
traces:
  code: [apps/simulation/assembly/actor/introspection.ts, apps/simulation/assembly/actor/actor.ts]

## P1-F01_7 — position snapshot: coordinates & level
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.SELF
priority: H
labels: [introspection, position]
rationale: Movement, observation, and emission workflows all depend on the authoritative position and level maintained by the actor.
acceptance:
  - Introspection exposes the actor's current X and Y coordinates from SelfState through getter functions.
  - Introspection exposes the actor's current level (vertical plane) through a getter that stays in sync with transitions.
  - A convenience getter returns the position as a Vec2 copy so callers can read location without mutating internal state.
  - After a transition mutates position or level, the introspection getters reflect the new values within the same tick.
verification:
  - unit: move an actor horizontally and vertically via transition helpers and verify the X, Y, level, and Vec2 getters return updated values while mutating the returned Vec2 leaves the internal state unchanged.
traces:
  code: [apps/simulation/assembly/actor/introspection.ts, apps/simulation/assembly/actor/actor.ts, apps/simulation/assembly/actor/transition.ts]

## P1-F02 — OBSERVATION (sensing environment)
status: META 
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.OBS
priority: H
labels: [observation, perception, updated]
rationale: The actor senses nearby entities and reports what it observes about them and itself. A higher-level coordinator composes these reports into a full map.
acceptance:
  - The actor gathers observation data within its configured range and records it in a consistent structure.
  - The actor reports only what it directly observes. Layered occupancy (surface, features, actors) is assembled by coordinators.
  - When a trusted coordinator requests Enhanced observation, the actor returns the richer details available.
verification:
  - unit: injecting environment frames yields expected sensed data; Enhanced requests produce richer details when enabled.
traces:
  code: [apps/simulation/assembly/actor/actor.ts]

## P1-F02_1 — interrogating surroundings, no constraints
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.OBS
priority: H
labels: [observation, perception]
rationale: The actor can use messages to interrogate the squares immediately sourounding it.
acceptance:
  - The observing actor can only interrogate the surrounding squares by message passing the actors that compose them.
  - If no messages are returned the actor only has information that the surrounding actor didn't provide a response but no details on what the surrounding actor is.
  - If the surrounding actor responds, the observing actor can determine information about it based on the observing actor's capabilities.
  - The higher the capabilities of the observing actor, the more information they can gather.
verification:
  - unit: the actor can determine what occupies it's immediate surroundings through message passing. It can interrogate the cardinal and intercardinal directions.
traces:
  code: [apps/simulation/assembly/actor/actor.ts]

## P1-F02_2 — structure of an observation
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.OBS
priority: H
labels: [observation, perception, memory]
rationale: The actor will capture observational information in a stuctured way in order to effectively use it for decision making.
acceptance:
  - All observations are gathered through interrogation.
  - An actor with basic observational capabilities will capture a basic fact on where it was when an observation was taken.
  - An actor with basic observational capabilities will capture a basic fact on where the actor it was observed when the observation was taken.
  - An actor with basic observational capabilities will capture a basic fact on the tick that the observation was recorded in.
  - An actor with basic observational capabilities actor will capture a basic fact on what it is observing. What comes in the context of the purpose of the actor it is observing. Is it observing a wall tile, a floor tile, or another ambulatory actor.
  - An actor with enhanced observational capabilities will capture complex facts that are not accessible through basic interrogation related to SelfState items such as vitals (health, stamina).
verification:
  - unit: An actor acting as a basic actor interrogates its surrounding actors and gathers basic information into an obvservation that it adds to observation item. An actor that is acting as an enhanced actor can collects additional information related to the SelfState of the actor it is observing and adds it to an observation item.
traces:
  code: [apps/simulation/assembly/actor/actor.ts]

## P1-F02_3 — observational range and memory
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.OBS
priority: H
labels: [observation, perception, memory]
rationale: The actor needs the concept of observational memory so that it can make a decision based on multiple prioritized observations, sometimes taken across multiple ticks.
acceptance:
  - The actor maintains an observation queue that it can add or delete information received from its interrogation of surrounding actors.
  - The observation storage queue at a minimum contains the result of interrogating the actors in the direct proximity known as the observational radar (N,E,S,W,NE,NW,SE,SW).
  - Based on a user supplied parameter measured in ticks the observation queue can store a history of observations based on the previous location the actor occupied and what it observed through interrogation from surrounding actors when it was in that area.
  - Based on a supplied parameter it is posible to increase the range of the observational radar.
  - Older observations are lower down in the queue and are treated as less relivatent in decision making.
  - Other than age, observations are given a priority based on what it relates to. If an ambulatory actor is spotted within its observational radar.
verification:
  - unit: The actor can move, interrogate surrounding actors for information, add observations about those actors to its local observational state, and drop observations from its queue based on how many observations are allowed by the ticks parameter and its observational radar.
traces:
  code: [apps/simulation/assembly/actor/actor.ts]

## P1-F03 — EVALUATION (cognition)
status: META
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.EVAL
priority: H
labels: [evaluation, cognition, decision-making, aiu]
rationale: The actor must decide actions using AIU modules, solver assistance, or instinct fallbacks.
acceptance:
  - Actors attach one or more AIU modules that define higher-order goals; evaluation invokes these modules to plan actions from observations and self state.
  - AIU modules remain granular—each covers a narrowly scoped behavior (e.g., exploration drift, entrance seeking, attack intent) and stacking multiple modules yields richer strategies.
  - AIU modules expose deterministic hooks (`prepareQuery`, `interpretResult`, `shouldFallback`) so evaluation can integrate with solvers (e.g., Z3) and degrade gracefully.
  - Evaluation maintains AIU priority/stacking: if one AIU fails (UNSAT or budget exhausted), the actor falls back to the next module or instinct behaviour, logging the failure for upstream review.
  - Evaluation operates per actor; even with identical directives or AIU loadouts, actors make decisions based on their own state/observations.
verification:
  - unit/integration: actors configured with AIUs produce solver queries, apply results, and fall back to instincts when necessary; telemetry captures AIU activations and outcomes.
traces:
  code: [backend/assembly/runtime/controller.ts, backend/assembly/runtime/reasoner_bridge.ts]

## P1-F03_2 — AIU module: find_exit
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.EVAL
priority: H
labels: [aiu, solver, navigation]
rationale: Actors need a granular behaviour that steers them toward known exits using solver reachability while degrading gracefully when paths are unavailable.
acceptance:
  - When `find_exit` is attached, the actor prepares reachability queries that target the nearest exit portal using deterministic budgets derived from distance and stamina.
  - Solver SAT responses yield single-step intents that advance toward the exit; UNSAT, timeout, or zero-step answers trigger the configured fallback (random walk) without stalling evaluation.
  - Actors remain stationary when already occupying the exit cell, avoiding redundant solver traffic.
  - Telemetry records the solver verdict code and the active AIU mode for downstream analysis.
verification:
  - unit: exercise the AIU runtime so SAT/UNSAT/timeout solver stubs drive the expected intent vectors and fallback selection.
  - integration: simulated actors equipped with `find_exit` move toward exit portals and emit telemetry documenting solver verdicts.
traces:
  code: [apps/simulation/assembly/configurator/aiuRuntime.ts]
  tests: [apps/simulation/tests/P3_F02_aiuModules.test.js]

## P1-F03_3 — AIU module: defend_exit
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.EVAL
priority: M
labels: [aiu, defense, solver]
rationale: Defensive actors require a guard-radius behaviour that keeps them anchored near exits while still participating in the deterministic solver pipeline.
acceptance:
  - The `defend_exit` AIU builds guard-radius solver queries centred on the tracked exit portal with bounded step budgets.
  - Solver verdicts map to zero-vector intents so the actor holds position; UNSAT responses reinforce the hold without consuming stamina.
  - When the solver is unavailable, the actor still emits a deterministic hold intent tagged with the last solver code for telemetry.
verification:
  - unit: guard-radius solver stubs return SAT/UNSAT and the AIU emits zero-movement intents with matching solver codes.
  - integration: actors using `defend_exit` remain within their guard radius over multiple ticks while telemetry shows the hold intent and solver outcomes.
traces:
  code: [apps/simulation/assembly/configurator/aiuRuntime.ts]
  tests: [apps/simulation/tests/P3_F02_aiuModules.test.js]

## P1-F03_4 — AIU module: patrol_corridor
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.EVAL
priority: M
labels: [aiu, patrol, waypoint]
rationale: Patrolling actors should cycle through corridor waypoints deterministically, advancing the sequence when solver guidance is available and remaining consistent when it is not.
acceptance:
  - The AIU prepares waypoint solver requests with deterministic hint vectors drawn from the patrol sequence.
  - SAT solver results advance along the hint direction and emit patrol metadata (`aiuMode`, auxiliary index) for telemetry.
  - When waypoints are blocked or the solver returns UNSAT/timeout, the AIU falls back to sequence-based movement while clamping deltas to valid single steps.
  - Patrol state (current index) persists across ticks so actors resume the correct waypoint after fallback or stationary ticks.
verification:
  - unit: simulated solver responses show the actor progressing through the patrol cycle and updating auxiliary metadata.
  - integration: actors with `patrol_corridor` traverse the sequence on open corridors and log solver fallbacks when blocked.
traces:
  code: [apps/simulation/assembly/configurator/aiuRuntime.ts]
  tests: [apps/simulation/tests/P3_F02_aiuModules.test.js]

## P1-F07 — Cultivation state & vitals regeneration
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.EVAL
priority: H
labels: [aiu, resources, regeneration, vulnerability]
rationale: Actors need a deliberate way to regenerate vitals when resources are depleted. Cultivation provides recovery at the cost of temporary vulnerability, enabling planners to trade mobility/combat readiness for regeneration.
acceptance:
  - Actors may attach a cultivation AIU that emits a zero-movement intent while active.
  - While cultivation is active and the actor stays stationary, stamina, health, mana, and durability regenerate at configured rates (baseline: existing regen values).
  - Baseline regeneration trades one vulnerable cultivation tick for approximately two deliberate actions: each tick restores at most `2 × minMeaningfulActionCost` stamina (and matches the same floor for other vitals), ensuring actors must remain stationary for multiple ticks to recover a sizable deficit; higher tier cultivation modules may raise the multiplier but never drop below this floor.
  - When an actor lacks an explicit cultivation AIU but exhausts its stamina/health/mana reserves, the runtime falls back to the default cultivation module so recovery can proceed deterministically.
  - Cultivation remains engaged until the actor has recovered enough stamina to perform a meaningful action: evaluation derives an exit threshold `S_exit = max(minMeaningfulActionCost, cultivation.minExitStamina)` (where `minMeaningfulActionCost` defaults to the cheapest non-instinct action, e.g., a single deliberate movement) and suppresses non-cultivation intents while S_C < S_exit, preventing rapid oscillation between cultivation and movement.
  - Cultivation tracks consecutive ticks spent in the state; upon exiting, a vulnerability window of ⌈√ticks_cultivated⌉ ticks is enforced where the actor cannot attack or defend.
  - Attempts to break vulnerability (attack/defend) before the window expires are rejected or demoted to instinct wait behaviour.
  - Telemetry records cultivation activation, the running tick counter (exposed per tick while cultivation is active), and resulting vulnerability windows.
verification:
  - unit: attach cultivation AIU, deplete stamina, confirm non-cultivation intents are denied until `S_C >= S_exit`, then assert vitals increase and vulnerability window blocks attack/defend intents until elapsed.
  - integration: confirm coordinator dispatch preserves zero-movement intents during cultivation, automatically engages fallback cultivation when actors are depleted, and telemetry streams cultivation status plus tick counters each tick alongside the computed vulnerability windows.
traces:
  code: [
    apps/simulation/assembly/configurator/aiuRuntime.ts,
    apps/simulation/assembly/configurator/configurator.ts,
    apps/simulation/assembly/coordinator/states/resolve.ts,
    apps/orchestrator/src/index.js,
  ]
  tests: [
    apps/simulation/tests/P3_F02_aiuModules.test.js,
    apps/orchestrator/tests/telemetrySchemas.test.ts,
    apps/orchestrator/tests/telemetryEnrichment.test.ts,
  ]

## P1-F03_0 — AIU registry contract
status: proposed
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.EVAL
priority: M
labels: [aiu, registry, modular]
rationale: AIU modules should be reusable assets with metadata so evaluation can attach them deterministically.
acceptance:
  - The runtime exposes an AIU registry listing module id, version, cost, prerequisites, and solver schema.
  - Actors request modules by id; evaluation validates prerequisites (stamina, perception, faction) before attaching.
  - Registry metadata marks each module's scope so multiple granular AIUs can be combined to form composite behaviors.
  - Registry lookups are deterministic and versioned so replay runs attach identical modules.
verification:
  - unit: loading AIUs from the registry attaches the correct modules; requesting unavailable AIUs raises deterministic errors.
traces:
  code: []

## P1-F03_1 — basic movement decisions
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.EVAL
priority: H
labels: [evaluation, cognition, decision-making, where to move]
rationale: Based on the actor's observations about his environment. It can only choose to move to a valid location.
acceptance:
  - The actor lists moves that are valid and moves that are not.
  - The actor stores a list of where it can and can not move to each tick.
  - The actor selects from the valid moves independently, without mirroring other actors unless identical conditions dictate it.
verification:
  - unit: create a set of candidate locations—some traversable, some blocked—place the actor, and evaluate where it can move.
traces:
  code: []

## P1-F04 — TRANSITION (motor/actions)
status: META
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.TRANSITION
priority: H
labels: [transition, action, motor]
rationale: The actor must change its state or position predictably, applying decisions from introspection, observation, and evaluation.
acceptance:
  - The actor transitions between states or positions in accordance with decisions and constraints.
  - The decision to enter a specific surface node may consult an external “enterability” verdict provided by a coordinator that understands layered occupancy.
verification:
  - unit: invoking transitions results in predictable changes in state or position.
traces:
  code: [backend/assembly/runtime/actor.ts, backend/assembly/runtime/intent.ts]

## P1-F04_1 — unconstrained movement
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.TRANSITION
priority: H
labels: [transition, action, motor, movement]
rationale: The actor must be able to move in two dimensions x and y coordinates AND where the level design permits increase or decrease their current vertical level.
acceptance:
  - The actor is initialized with an x and y coorindate.
  - The actor moves from one x, y coordinate in a specified direction.
  - The actor can move up a level and down a level.
verification:
  - unit: invoking movement results in predictable changes in state or position.
traces:
  code: []

## P1-F04_2 — constrained movement (obstacles)
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.TRANSITION
priority: H
labels: [transition, action, motor, movement, obstacles]
rationale: The actor can move in directions that are not occupied by other actors whether they are static, like an obstacle, or ambulatory.
acceptance:
  - The actor can move to unoccupied actor tiles that have the purpose of floor tiles.
  - The actor can't pass through stationary actors like walls or obstacles.
  - The actor can't pass through other ambulatory actors that are occuping a space that the actor has the ability to move to in an onconstrained state.
verification:
  - unit: invoking movement results in predictable changes in state or position.
traces:
  code: []

## P1-F04_3 — stamina reducing movement
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.TRANSITION
priority: H
labels: [transition, action, motor, movement, stamina]
rationale: The actor spends from its current resource pillar to change state. Movement consumes current stamina.
acceptance:
  - If the actor wishes to move, they consume a fraction of their current stamina.
  - The actor can only move if they have stamina.
  - Stamina cost is based on a percentage of maximum staminia. 
  - Moving in the cardinal directions consumes a standard percent of stamina (based on percentage of total.)
  - Moving in the inter-cardinal directions consumes √2 x the standard percent of stamina.
  - Moving down a level uses √3 x the standard percentage of stamina.
verification:
  - unit: invoking one or more actors with some current staminia, move them around by changing their x, y, and level, ensure that the appropraite amount of stamina is used based on type of movement, ensure that an actor that does not have enough stamina can not make the requested movement.
traces:
  code: []

## P1-F04_4 — barrier immobility
status: proposed
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.TRANSITION
priority: M
labels: [transition, barriers]
rationale: Internal barriers are represented by actors but must remain stationary while still emitting telemetry.
acceptance:
  - Actors provisioned with the barrier role never enqueue movement intents and always report a zero vector when interrogated.
  - Barrier actors may still observe and emit so downstream personas can include them in telemetry feeds.
  - Attempts to dispatch a barrier actor are rejected with a deterministic outcome that leaves its state unchanged.
verification:
  - unit: processing a barrier actor through the lifecycle yields no movement intents and produces a rejection outcome if a move is forced.
traces:
  code: []

## P1-F05 — EMISSION (communication)
status: META
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.EMMIS
priority: M
labels: [emission, communication]
rationale: The actor must emit signals to its environment that can be observed by other actors.
acceptance:
  - The actor emits messages or signals that are detectable by actors in proximity.
verification:
  - unit: one actor emits, another actor ingests the message.
traces:
  code: [backend/assembly/runtime/emission.ts]

## P1-F05_1 — simple message passing
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.IMMIS
priority: M
labels: [emission, communication, message passing]
rationale: The actors both pooled and individual need to pass information between other actors in their proximity.
acceptance:
  - A message can be passed from actor to actor within a defined radius.
  - Actors outside of the radius can't easdrop on a message.
  - The message queue has a limited size with the oldest messages dropping when it reaches the end of its queue.
  - Each actor gets a "read receipt" when another actor has read its message.
  - Messages can result in actor action.
  - The basic information that all actors MUST provide on interrogation is their current location (x,y,level) and the locations of all sounding actors if they exist.
  - If a tile does not have any tiles surrounding them in the cardnal or inter-cardinal directions it responds with no information for that location.
verification:
  - unit: one actor emits, another actor ingests the message.
traces:
  code: [backend/assembly/runtime/emission.ts]

## P1-F05_2 — actions based on requests, no contraints
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.EMMIS
priority: M
labels: [emission, communication, message passing]
rationale: One actor can pass messages along to another actor and request information about it. This is a form of local gossip network.
acceptance:
  - Actors can respond to an interrogation message.
  - Actors can send basic information about themselves to the interrogating party.
verification:
  - unit: one actor sends a request to another actor using a specific message type, the the actor receiving the request sends information about itself to the requesting actor.
traces:
  code: [backend/assembly/runtime/emission.ts]

## P1-F06 — DISPATCH QUEUE COMPLIANCE
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.TRANS
priority: H
labels: [queue, configurator, scheduling]
rationale: Actors must honour the configurator’s dispatch queue so movement ordering stays deterministic and auditable across personas.
acceptance:
  - The actor exposes an API to accept a dispatch permit (tick metadata, intent delta, tier indicator) and does not move until a permit arrives.
  - When applying a permit, the actor validates the intent against current stamina, enterability data, and its latest observations; rejection is emitted when the move is unsafe.
  - Rejections include a structured reason code that the configurator can archive in the dispatch history before progressing to the next actor.
  - Actors ignore duplicate or out-of-order permits, ensuring the configurator remains the single arbiter of movement order.
verification:
  - integration: a multi-actor scenario driven through the configurator dispatch queue shows actors acting only with permits, including successful moves and logged rejections.
traces:
  code: [apps/simulation/assembly/actor/actor.ts, apps/simulation/tests/P1_orchestration.test.js]

## P1-N06 — ACTOR STATEFLOW (design intent)
status: META
owner: system
req_type: NON_FUNCTIONAL
phase: runtime
area: ACTOR.ARCH
priority: H
labels: [design, architecture, orchestration]
rationale: The actor’s internal behavior should follow a clear and consistent cycle of states, with each state focusing on a specific aspect of the actor’s role. This keeps the design understandable, testable, and extensible.
acceptance:
  - The actor’s top-level cycle follows a predictable order: introspection, observation, evaluation, transition, emission.
  - Each state is responsible only for its own concerns (e.g., self-awareness, sensing, decision-making, acting, communicating).
  - The top-level cycle ensures the actor produces at most one action per tick and exposes its reasoning through observable events.
verification:
  - design review confirms that each functional module aligns with its corresponding top-level requirement (P1-F01 to P1-F05).
  - integration tests confirm that the cycle runs in the intended order and does not produce more than one action per tick.
traces:
  code: [backend/assembly/runtime/actor_fsm.ts]


## P1-N07_1 - configuration actors up to purpose
status: active
owner: system
req_type: NON_FUNCTIONAL
phase: runtime
area: ACTOR.ARCH
priority: H
labels: [actor configuration]
rationale: The system must support the ability to configure actors according to purpose.
acceptance:
  - The system must allow for configuing actors on creation including setting of selfState attributes.
verification:
  - Actors are created with multiple different configurations and checked to see if they hold the appropriate configuration after creation.
traces:
  code: []

## P1-N08 — ACTOR POOLING (deployment strategy)
status: META
owner: system
req_type: NON_FUNCTIONAL
phase: runtime
area: ACTOR.ARCH
priority: H
labels: [pooling, scalability, deployment, updated]
rationale: The platform must support many actors at once by grouping simple actors together while letting advanced actors run independently. Actors remain pool‑agnostic so they can be reused in different contexts.
acceptance:
  - The system can host large numbers of lightweight actors without exhausting a single thread.
  - More capable actors are able to run without being slowed down by the pooled group.
  - Each actor can be created, tracked, and removed individually, regardless of which execution style it uses.
  - Pool membership is managed outside the actor. Actors do not carry a mutable “isPooled” flag.
  - Optionally, actors may expose read‑only provenance (for example, standalone or pooled origin) via host-provided metadata.
verification:
  - design review confirms that pooling and individual execution paths coexist and cover all actor types.
  - performance tests demonstrate that adding pooled actors does not delay the specialised actors beyond agreed limits.
traces:
  code: []

## P1-N11 — LM PRIVILEGES (coordinator observation)
status: NON_FUNCTIONAL
owner: system
req_type: NON_FUNCTIONAL
phase: runtime
area: ACTOR.OBS
priority: M
labels: [privileges, orchestration, new]
rationale: The configurator orchestrates many actors and requires a reliable way to request enhanced observations.
acceptance:
  - When a trusted coordinator requests Enhanced observations, actors honor the request and return the richer details available.
  - Actors do not enforce a policy that blocks coordinator observation within configured limits.
verification:
  - unit: a privileged caller obtains Enhanced observations from static and mobile actors under normal conditions.
traces:
  code: [apps/simulation/assembly/actor/actor.ts]

## P1-N08_1 — pooled simple actors
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.ARCH
priority: H
labels: [pooling, scalability, simpletons]
rationale: Most actors are basic “simpletons” that only need the shared worker. They must be able to communicate and update in that shared space without stepping on each other. Examples of simpleton actors are walls and floor tiles.
acceptance:
  - Simple actors can join a shared pool and run on the same thread without blocking the interface.
  - The pool processes each member in order and keeps their state separate.
  - Messages or nudges that belong to one pooled actor do not leak into another.
verification:
  - unit: create several pooled actors and confirm they each retain independent positions and status through multiple ticks.
  - performance: measure a large batch of pooled actors and confirm frame time stays within budget.
traces:
  code: []

## P1-N08_2 — dedicated specialists
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: ACTOR.ARCH
priority: H
labels: [workers, specialists, isolation]
rationale: “Intellectual” actors need their own worker threads so they can plan, sense, and react without delays from the crowd.
acceptance:
  - An intellectual actor can start in its own worker and keep running even if the pooled group is busy.
  - The system only introduces a connection between intellectuals when they come close enough to interact.
  - When an intellectual actor ends, its worker releases resources and the actor is removed cleanly.
verification:
  - integration: run an intellectual actor alongside a busy pool and confirm its tick timing stays within its limit.
  - unit: place intellectual actors far apart, then bring them together and confirm proximity triggers communication while distance breaks it again.
traces:
  code: []

## P1-N09 — resource snapshot encoding (stamina/health/mana pillars)
status: draft
owner: system
req_type: NON_FUNCTIONAL
phase: runtime
area: ACTOR.SELF
priority: H
labels: [introspection, encoding, bitpack]
rationale: Pillar snapshots must serialize into compact 32-bit words while preserving large maxima and percentage-based current/regen rates.
acceptance:
  - Each pillar is encoded as a single little-endian u32 with layout:
      * bits 31..20: max_mantissa (12-bit unsigned)
      * bits 19..16: max_exponent (4-bit unsigned)
      * bits 15..8 : current_percent (8-bit unsigned) where current = round(max * current_percent / 255)
      * bits 7..0  : regen payload; bit7 is sign (0 = regen, 1 = degeneration), bits 6..0 magnitude where |regen| = round(max * magnitude / 127) per tick.
  - max is reconstructed as (max_mantissa << max_exponent); implementations must treat max_mantissa = 0 as max = 0 regardless of exponent.
  - Encoding clamps inputs so current stays within [0, max] and regen magnitude reflects a percentage ≤ 100% of max per tick.
  - Actors decoding the word reproduce the same max/current/regen values (within one rounding unit) used during encoding.
verification:
  - unit: round-trip tests encode known (max, current, regen) tuples into the 32-bit format, then decode and assert max/current/regen match expected integer results and rounding behaviour.
  - unit: boundary tests cover exponent saturation, zero/negative regen, and full depletion/recovery percentages.
traces:
  code: [backend/schemas/actor-schema.json, apps/simulation/assembly/actor/contracts.ts (future encode/decode helpers)]

## P1-N10 — ORCHESTRATION
status: active
owner: system
req_type: NON_FUNCTIONAL
phase: runtime
area: ACTOR.ORCH
priority: H
labels: [actor pool, movement, decision making, observation]
rationale: Test the implementation of all the actor functionality by create a group of actors and having them navigate around a surface of actor tiles and interact with obstacles and each other to create a visual map of a level
acceptance:
  - Multiple agenst created.
  - Static actors created as pooled actors.
  - Ambulatory actors created as dedicated specialists
  - Test run across multiple ticks.
  - Specialist actors move each tick.
  - Specialist actors observe stamina drain on each movement according to movement type
  - A visual map is created from the observations of the actor-space as specialists move around the space.
verification:
  - integration: run the entire simulation across multiple ticks, ensure all supporting functionality behaves as expected.
traces:
  code: []

## P1-N12 — Layout manager control contract
status: NON_FUNCTIONAL
owner: system
req_type: NON_FUNCTIONAL
phase: runtime
area: ACTOR.ORCH
priority: M
labels: [orchestration, control, new]
rationale: Actors must respond predictably when the configurator issues movement or observation commands on their behalf.
acceptance:
  - Actors accept externally driven movement commands (for example, issued by the configurator) as long as stamina and enterability checks pass.
  - Actors expose their observation results through existing getters so the configurator can assemble a full map without additional hooks.
  - Failing preconditions (such as insufficient stamina) are reported back to the caller with existing error codes or return values.
verification:
  - integration: a layout-manager-driven simulation moves and senses through the public actor APIs without requiring test-only helpers.
traces:
  code: [apps/simulation/assembly/actor/actor.ts]


---

## Appendix — Notes
- P1-N06 provides architectural guidance: it establishes that the top-level actor FSM orchestrates the functional umbrellas P1-F01 through P1-F05.
- Each functional area (INTROSPECTION, OBSERVATION, EVALUATION, TRANSITION, EMISSION) is realized as a domain-specific state machine under this cycle.
- P1-N06 is non-functional: it describes design intent, not specific implementation details.

## Appendix — Field Intent
This appendix explains the purpose of each field in the requirement entries, to help maintain clarity and consistency across requirements.

- **status:** Lifecycle or maturity of the requirement (e.g., META, active, draft). Indicates whether the requirement is guiding principle, implemented, or under development.
- **owner:** Who is accountable for the requirement (e.g., system, team, persona). Helps trace responsibility for changes or clarifications.
- **req_type:** Classification of the requirement, usually **FUNCTIONAL** (what the system must do) or **NON_FUNCTIONAL** (quality attributes, constraints, design intent).
- **phase:** The stage of the lifecycle where the requirement applies (e.g., runtime, compile-time, design).
- **area:** Subsystem or domain the requirement belongs to (e.g., ACTOR.SELF, ACTOR.OBS, ACTOR.EVAL).
- **priority:** Relative importance of the requirement (e.g., H = high, M = medium, L = low). Guides implementation and testing order.
- **labels:** Keywords to categorize and quickly search/filter requirements (e.g., introspection, stamina, pooling).
- **rationale:** The “why” of the requirement — justification for its existence and the problem it addresses.
- **acceptance:** Conditions of satisfaction. What must be true for the requirement to be considered fulfilled. Written in outcome-focused terms.
- **verification:** The “how” of testing or proving the acceptance criteria. May include unit, integration, design review, or performance testing methods.
- **traces:** References to implementation artifacts (e.g., code files, modules) that realize this requirement. Supports traceability from requirement to code/tests.
