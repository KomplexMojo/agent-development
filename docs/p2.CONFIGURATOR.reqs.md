### Configurator
Controls the dials.

## P2-F01 — LAYOUT (creating a playable surface)
status: META
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.CORE
priority: H
labels: [layout, positioning, placement]
rationale: The configurator plans and maintains a coherent level so actors can explore a complete, functional space.
acceptance:
  - The configurator provides capabilities to build rooms, hallways, stair connectors, obstacles, and anchors for start and end points.
  - Levels produced by the configurator keep the start and end locations reachable through walkable surfaces.
  - The behaviours defined in P2-F01_1 through P2-F01_7 are delivered.
verification:
  - review: design walk-through confirms each child requirement is implemented and linked to this meta requirement.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F01_1 — Static surface pooling
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.ROOM
priority: H
labels: [surfaces, pooling, static, updated]
rationale: Rooms and hallways depend on a ready supply of static surfaces that share consistent properties and reporting contracts.
acceptance:
  - The configurator coordinates with a surface module to create and recycle a pool of static surface actors before placement.
  - Surface actors expose infinite durability while stamina, health, and mana remain at zero.
  - The configurator records placement metadata for each surface and maintains a surface map derived from actor observations.
  - Surfaces may be backed by real actor handles so the configurator can reuse actor introspection and observation.
  - The surface module provides batch interrogation helpers so the configurator can refresh observations across the pool using Enhanced capability.
verification:
  - unit: creating a configurator instance produces the surface pool and confirms each surface presents the expected resource pillars, observation hooks, and placement metadata for the surface map.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts, apps/simulation/assembly/configurator/surface.ts]

## P2-F01_2 — Room tessellation
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.ROOM
priority: H
labels: [room, tessellation]
rationale: Actors need continuous walkable areas that represent interior rooms.
acceptance:
  - The configurator assembles rooms by arranging surface actors in the requested dimensions.
  - Rooms are flagged as walkable regions and expose their bounding coordinates for navigation.
  - Room construction avoids gaps so actors do not fall through or encounter missing surfaces.
verification:
  - unit: requesting rooms of various sizes produces layouts whose surface counts and bounds match the request and contain no missing cells.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F01_3 — Hallway routing
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.HALLWAY
priority: H
labels: [hallway, routing]
rationale: Rooms must be linked by hallways so actors can travel between them.
acceptance:
  - The configurator connects rooms by building hallways using surfaces from the pool.
  - Hallways maintain continuous walkable paths without diagonals or breaks that would block movement.
  - Hallway segments track their source and destination rooms for debugging and analytics.
verification:
  - unit: laying out two rooms requests a hallway path and confirms the generated surfaces create a single connected corridor that links both rooms.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F01_4 — Entry and exit anchoring
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.NAVIGATION
priority: H
labels: [anchors, navigation]
rationale: Levels require clear starting and ending points for actors and gameplay flow.
acceptance:
  - The configurator selects start and end locations aligned with cardinal directions (north, east, south, or west).
  - Anchors are placed on valid walkable surfaces and marked with metadata so other systems can load them quickly.
  - The configurator prevents anchors from overlapping obstacles or out-of-bounds areas.
verification:
  - unit: generating layouts with different anchor directions confirms the selected surfaces are walkable, tagged, and free from conflicts.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F01_5 — Solvability assurance
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.NAVIGATION
priority: H
labels: [solver, validation]
rationale: Actors must be able to traverse the generated level from start to end.
acceptance:
  - After building a layout, the manager runs a reachability check to confirm the start connects to the end.
  - The configurator configures a deterministic solver (e.g., Z3) with the blueprint’s constraints (including AIU goal clauses) to prove a valid path exists between anchors and satisfies faction objectives.
  - If the solver detects a blockage or unsatisfied constraint, the configurator either repairs the layout or rejects the blueprint with diagnostics (failing clauses, blocked coordinates, AIU conflicts) before publishing it.
  - The configurator records solver inputs, verdicts, and remediation actions for observability and debugging.
verification:
  - unit: providing both valid and intentionally blocked layouts exercises the solver and confirms it approves passable maps and rejects blocked ones.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F01_6 — Obstacle seeding
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.ROOM
priority: M
labels: [obstacles, balance]
rationale: Obstacles introduce variety and challenge without compromising core traversal paths.
acceptance:
  - The configurator places obstacles inside rooms according to a configurable density or pattern.
  - Obstacles use the correct resource pillars and stand on valid surfaces without overlapping anchors or hallways.
  - Obstacle placement preserves at least one clear path verified by the solver.
verification:
  - unit: generating rooms with obstacle settings confirms the expected count of obstacles and re-runs the solver to ensure the level remains passable.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F01_7 — Vertical connectors
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.VERTICAL
priority: M
labels: [stairs, vertical]
rationale: Multi-level layouts need a clear way for actors to move between floors.
acceptance:
  - The configurator creates stair or ladder surface connectors that link source and destination levels.
  - Vertical connectors include metadata that identifies both connected levels and ensures actors align correctly when transitioning.
  - Connectors integrate with the solver so inter-level paths remain verified.
verification:
  - unit: generating layouts with vertical connectors confirms the connectors are placed on matching coordinates across levels and remain reachable by the solver.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F01_8 — Organic surface layouts
status: proposed
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.ROOM
priority: M
labels: [surfaces, organic, topology]
rationale: Some experiences require walkable spaces defined by organic shapes rather than rectilinear lattices while still guaranteeing traversable routes for actors.
acceptance:
  - The configurator represents walkable surfaces as arbitrary collections of connected surface nodes (polygons, splines, or irregular tiles) instead of assuming a fixed lattice.
  - Layout requests may target opposing boundary classes (e.g., entry edge vs. exit edge); the configurator ensures at least one continuous walkable corridor spans the requested boundaries even when the silhouette is organic.
  - Surface metadata records adjacency lists and boundary labels so downstream systems (visualizers, solvers) can reason about non-rectilinear contours.
  - Exported telemetry (ASCII and JSON) includes sufficient hints—such as control points, masks, or topology descriptors—for tooling to reproduce organic silhouettes without snapping back to an orthogonal lattice.
verification:
  - design review: walk-through of the surface representation confirms irregular layouts can be authored, visualised, and solved using the documented contracts.
traces:
  code: [
    apps/simulation/assembly/configurator/configurator.ts,
    apps/simulation/assembly/configurator/aiuRuntime.ts,
    apps/simulation/assembly/coordinator/states/resolve.ts,
  ]
  tests: [
    apps/simulation/tests/P3_F02_aiuModules.test.js,
    apps/simulation/tests/P3_F04_aiuPrerequisites.test.js,
  ]

## P2-F01_9 — Blueprint ingestion & negotiation
status: proposed
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.CORE
priority: M
labels: [blueprint, ai, negotiation]
rationale: AI-authored layout plans must be translated into deterministic surfaces while supporting iteration when constraints fail.
acceptance:
  - The configurator accepts director-issued layout blueprints and maps rooms, connectors, anchor hints, and actor spawn intents onto the surface grid while respecting user parameters (width, height, actor/barrier budgets).
  - Blueprint consumption records how abstract rooms, connectors, and spawn regions were converted into concrete coordinates, noting any adjustments (rounding, padding, collision resolution) applied during placement.
  - AIU recommendations are cross-checked against the registry and scenario budget; the configurator rejects or downgrades entries that exceed cost or violate constraints.
  - When solver validation fails, the configurator emits a structured rejection (including failing constraints, blocked coordinates, or AIU conflicts) so the director/AI pipeline can propose a revised blueprint.
  - Accepted blueprints are persisted with revision identifiers, actor loadout metadata, and provenance so telemetry/replay tooling reproduces the chosen layout.
verification:
  - integration: feeding mocked blueprint directives produces deterministic surface layouts; intentionally invalid blueprints trigger rejection responses with detailed diagnostics.
traces:
  code: []

## P2-F04_5 — Actor loadout placement
status: proposed
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.PROPOSAL
priority: M
labels: [actors, aiu, placement]
rationale: Actor spawn recommendations and AIU loadouts must be instantiated deterministically and within budget.
acceptance:
  - During proposal, the configurator instantiates the requested actor groups, selecting spawn surfaces that satisfy blueprint intents (near/inside rooms, faction zones) without blocking solver-validated paths.
  - Each actor is assigned the approved AIU loadout (supporting multi-AIU “stacked” behaviours when the director requests them); the configurator debits the budget ledger and records per-actor AIU attachments and their composition order for telemetry.
  - Placement failures (no valid spawn cell, budget exhausted) trigger structured rejection or downgrade messages fed back to the director.
  - Proposal outputs include an actor placement ledger (handle, coordinates, faction, AIUs, cost).
verification:
  - unit/integration: sample blueprints create actors with expected AIUs and placement; forced failure scenarios trigger downgrade/rejection pathways.
traces:
  code: []

## P2-F05_4 — AIU audit telemetry
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.OBSERVATION
priority: M
labels: [telemetry, aiu, audit]
rationale: Designers need to review which AIUs were activated, solver outcomes, and budget consumption to tune scenarios.
acceptance:
  - Observation aggregation records per-tick AIU activations, solver success/failure, cultivation/vulnerability counters, and remaining budget so downstream tooling can compare behaviours across runs.
  - Telemetry exports AIU template ids, module kinds, solver verdict codes, and mode-specific metadata (`aiuMode`, patrol index, cultivation ticks) for every actor tick.
  - Telemetry records director/orchestrator provenance per run (guidance plan id, AI model identity, prompt/response hashes) and lists per-actor AIU changes (applied vs. dropped) so auditors can reconstruct why behaviours diverged from the proposal.
  - Rejected or downgraded AIUs (e.g., unmet prerequisites, fallback modules) emit deterministic audit entries so the director can reconcile budget usage.
verification:
  - integration: orchestrator telemetry fixtures validate against `telemetry.raw.v2`/`telemetry.ui.v1` schemas and assert the presence of AIU metadata.
  - unit: configurator dispatch tests confirm cultivation and vulnerability counters propagate into telemetry payloads.
traces:
  code: [apps/simulation/assembly/configurator/configurator.ts, apps/orchestrator/src/index.js]
  tests: [apps/orchestrator/tests/telemetrySchemas.test.ts, apps/orchestrator/tests/telemetryEnrichment.test.ts]

## P2-F02 — LEVEL STATEFLOW (coordinating phases)
status: META
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.CORE
priority: H
labels: [fsm, lifecycle, updated]
rationale: The configurator advances through named phases so level construction is predictable and observable.
acceptance:
  - The lifecycle covers at least plan, propose, poke/observe, verify, and confirm phases with clear entry and exit rules.
  - Plan/propose phases negotiate AI blueprints: request guidance, ingest and validate layout + actor/AIU recommendations, perform budget checks, and only enter verify after acknowledgement.
  - State transitions are deterministic, logged, and expose failure reasons when guard checks (including solver verdicts, budget overruns, or blueprint rejection) block progress.
  - Child requirements P2-F02_1 and onward detail the behaviours executed inside each phase.
verification:
  - review: architecture review verifies the state machine implementation covers all phases and maps to the documented transitions.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F02_1 — Phase execution handlers
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.CORE
priority: M
labels: [fsm, handlers, new]
rationale: External coordinators often need to advance the configurator one phase at a time rather than running the entire lifecycle in one call.
acceptance:
  - Each lifecycle phase exposes a callable handler that performs the work for that phase and reports success or failure.
  - Handlers validate preconditions; for example, the propose handler refuses to run until a valid blueprint is present.
  - Handler results include enough diagnostic detail for callers to understand why a phase failed and what remediation is required.
verification:
  - unit: invoking handlers sequentially progresses through the lifecycle, while out-of-order calls are rejected with descriptive statuses.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F03 — LEVEL PLANNING (deriving intent)
status: META
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.PLAN
priority: H
labels: [planning, budgets]
rationale: Before placing actors, the configurator needs a plan that captures room shapes, connectors, and content budgets.
acceptance:
  - Planning produces a structured plan object that includes requested rooms, hallways, stairs, and obstacle budgets.
  - Inputs such as seeds, size constraints, and configuration presets are recorded for later audit.
  - Child requirements (P2-F03_1+) define how each plan component is generated.
verification:
  - review: traceability check confirms the plan object contents align with configuration and are passed into downstream phases.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F03_1 — Layout blueprint generation
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.PLAN
priority: H
labels: [planning, blueprint, new]
rationale: A deterministic blueprint lets designers and automated systems reproduce the same level layout and understand how it was assembled.
acceptance:
  - Given a configuration payload (seed, room arrangement, hallway style, feature mix, actor spawn rules) the planner produces a blueprint that lists every surface coordinate, feature placement, and actor spawn point.
  - Running the planner twice with the same inputs yields the same blueprint, ensuring deterministic builds.
  - The blueprint records provenance metadata such as the configuration name and random seed so audits can trace the origin of generated layouts.
verification:
  - unit: planning with fixture inputs generates the expected blueprint structure and matches stored golden references.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F04 — LEVEL PROPOSAL (placing actors)
status: META
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.PROPOSAL
priority: H
labels: [placement, proposal]
rationale: The configurator populates the level by instantiating static actors according to the plan.
acceptance:
  - The proposal stage issues placement commands for rooms, hallways, stairs, and obstacles using pooled actors.
  - Proposal outputs include a placement ledger that lists every actor handle, location, and resource profile.
  - Child requirements (P2-F04_1+) describe how each asset type is placed and validated.
verification:
  - unit: proposal execution under test configuration yields placements that mirror the plan inputs and respect resource rules.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F05 — OBSERVATION AGGREGATION (collecting reports)
status: META
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.OBSERVE
priority: H
labels: [observations, telemetry, updated]
rationale: Static actors observe their surroundings, and the configurator must capture those reports to understand the final level.
acceptance:
  - The configurator subscribes to observation events from each placed actor and stores their latest reports.
  - Observation records include occupant types, adjacency, and anomalies so downstream systems can inspect them.
  - Child requirements (P2-F05_1+) focus on subscription setup, event handling, and storage formats.
verification:
  - unit: simulated observation events are processed and persisted in the configurator’s observation store without loss.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F06 — LEVEL MAP ASSEMBLY (building world view)
status: META
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.MAP
priority: H
labels: [map, aggregation, updated]
rationale: The configurator maintains an authoritative map derived from proposals and observations.
acceptance:
  - The level map merges placement data and observation reports into a coherent structure for navigation and visualization.
  - The map supports queries by surface position, adjacency, and level, enabling other systems to inspect it.
  - Child requirements (P2-F06_1+) specify data structures, update rules, and synchronization with observations.
verification:
  - unit: map assembly tests confirm updates reflect new observations and maintain consistent adjacency data.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F07 — SOLVER VERIFICATION (validating traversal)
status: META
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.VERIFY
priority: H
labels: [solver, validation, updated]
rationale: The configurator validates that the constructed level is traversable and meets configuration goals.
acceptance:
  - The solver receives the assembled map and returns pass or fail results that the configurator interprets.
  - Failures trigger remediation steps or retries documented by child requirements (P2-F07_1+).
  - Solver telemetry, including timings and failure reasons, is recorded.
verification:
  - unit: solver integration tests inject known passable and blocked layouts and confirm the configurator reacts appropriately.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F08 — LEVEL CONFIRMATION (publishing results)
status: META
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.CONFIRM
priority: H
labels: [publish, readiness]
rationale: Once a layout passes verification, the configurator publishes it for consumers and locks further changes.
acceptance:
  - Confirmation transitions the configurator into a ready state and exposes the final map to downstream systems.
  - The configurator records confirmation metadata such as signatures, timestamps, and version identifiers.
  - Child requirements (P2-F08_1+) cover event emission, hand-off protocols, and reset behaviour for the next cycle.
verification:
  - review: integration review confirms consumers receive the final map only after successful solver verification and confirmation logging.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F05_2 — Enhanced scan sweep
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.OBSERVE
priority: M
labels: [enhanced, scan, new]
rationale: Before verification the configurator needs a fresh, rich snapshot from all placed entities.
acceptance:
  - The configurator issues batch Enhanced observation requests to all pooled surfaces and staged actors.
  - Each request returns a ticket or version id that can be matched to received results.
verification:
  - unit: a scan sweep over a small layout produces tickets for all entities and updates the observation store.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F05_3 — Observation reconciliation
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.OBSERVE
priority: M
labels: [reconciliation, map, new]
rationale: Reports arrive at different times and need to be merged into a single view.
acceptance:
  - The configurator merges new observations into the level map, tolerating late or missing reports without stalling.
  - The latest valid report overwrites older data for the same cell.
verification:
  - unit: interleaved reports update the map deterministically and preserve coherence.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F06_1 — Layered occupancy model
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.MAP
priority: H
labels: [layers, occupancy, new]
rationale: Each cell must represent substrate surface, optional features, and optional actors to reflect real gameplay rules.
acceptance:
  - The map maintains a surface layer (always one), a feature layer (optional), and an actor layer (at most one actor).
  - Co‑location is allowed for surface+actor; actor+actor is rejected; feature rules depend on type.
verification:
  - unit: writing to each layer produces expected enterable/blocked results for the cell.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F06_2 — Enterability checks
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.MAP
priority: H
labels: [movement, validation, new]
rationale: Movement must consult the combined truth of all layers.
acceptance:
  - The configurator exposes an `isCellEnterable(x, y, level)` check that considers substrate, features, and actors.
  - The check returns true only when a surface exists, no blocking feature is present, and no actor occupies the target cell.
verification:
  - unit: toggling features and actors changes enterability as expected.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F06_3 — Internal barriers (non-ambulatory actors)
status: proposed
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.MAP
priority: M
labels: [barriers, occupancy, actors]
rationale: Some layouts need impassable obstacles that participate in telemetry like actors but never request movement.
acceptance:
  - The configurator records barrier placements in the actor ledger with a distinct role flag while keeping them separate from the surface pool.
  - Enterability checks treat barrier actors as blocking even when no other actors are present.
  - Dispatch staging excludes barrier actors so they never appear in movement queues or borrow from the actor pool.
  - Telemetry exports (ASCII and JSON) retain barrier metadata so downstream tools can render and analyse them distinctly from ambulatory actors.
verification:
  - unit: placing a barrier marks the cell as non-enterable, leaves the ambulatory actor pool unchanged, and the dispatch queue omits the barrier handle.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F06_4 — Portal tagging (entrance/exit anchors)
status: proposed
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.MAP
priority: M
labels: [portals, anchors, navigation]
rationale: Levels require explicit entrance and exit anchors so higher level personas can spawn actors and evaluate completion criteria.
acceptance:
  - The configurator marks designated surface cells as `entrance` or `exit` portals without disrupting existing occupancy layers.
  - Each cell exposes its portal classification so navigation logic and telemetry can reference anchors deterministically.
  - Portals can be cleared or re-tagged during layout updates without leaving stale state in the map.
verification:
  - unit: assigning entrance/exit portals to surface cells returns the expected classifications, and clearing portals resets the markers.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F06_5 — Stair connectors (up-level/down-level markers)
status: proposed
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.MAP
priority: M
labels: [stairs, vertical, navigation]
rationale: Multi-level layouts need explicit stair anchors so actors can transition between levels and planners can map viable elevation changes.
acceptance:
  - The configurator tags surface cells as `up-level` or `down-level` stairs without altering existing surface/feature occupancy.
  - Consumers can query, update, or clear stair designations deterministically during layout edits.
  - Telemetry emitted for the demo reflects stair placements so visualisations can highlight vertical connectors.
verification:
  - unit: assigning stair markers to surface cells returns the expected classifications, clearing them resets the cell, and attempts to tag non-surface cells are rejected.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F07_2 — Substrate-only connectivity
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.VERIFY
priority: M
labels: [solver, substrate, new]
rationale: Transient actor positions should not affect whether a level is solvable.
acceptance:
  - The solver evaluates connectivity on the surface layer only; actor positions do not influence solvability.
verification:
  - unit: layouts remain solvable regardless of temporary actor placements.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F04_2 — Surface placement ledger
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.PROPOSAL
priority: M
labels: [placement, audit, new]
rationale: Proposals must be auditable so designers can replay or inspect how a level was assembled.
acceptance:
  - The configurator records each placed surface with its id, position, level, and provenance.
  - The ledger supports simple queries (by id, position, or batch) for debugging and analytics.
verification:
  - unit: surface placement produces a ledger entry for each surface and can be retrieved by id and position.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F04_3 — Actor placement ledger
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.PROPOSAL
priority: M
labels: [actors, placement, audit, new]
rationale: Dynamic actors must be tracked as they are spawned, moved, or removed from a level.
acceptance:
  - The configurator records actor spawns and despawns with handle, position, and intended role.
  - The layout enforces one-actor-per-cell and rejects conflicting placements.
verification:
  - unit: spawning and removing an actor updates the ledger; conflicting spawns are rejected.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F04_4 — Surface provisioning from blueprint
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.PROPOSAL
priority: H
labels: [proposal, surfaces, new]
rationale: After planning, the configurator must instantiate the surfaces described in the blueprint so the rest of the lifecycle has a physical substrate to work with.
acceptance:
  - The proposal phase walks the blueprint and creates surfaces, registering each surface in the ledger and layered map.
  - Provisioning failures (for example, running out of pooled surfaces) are reported and block the proposal phase until resolved.
  - Once provisioning completes, a connectivity check confirms the start and end anchors specified in the blueprint are reachable.
verification:
  - unit: provisioning a sample blueprint creates the expected surfaces and the solver confirms the planned paths exist.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F04_5 — Actor provisioning from blueprint
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.PROPOSAL
priority: M
labels: [actors, provisioning, new]
rationale: Dynamic actors described in the blueprint must be spawned, tracked, and integrated with the map before the level can run.
acceptance:
  - The proposal phase borrows actors from the pool, places them at their spawn coordinates, and records them in the actor ledger and map as one atomic step.
  - If placement fails (for example the cell is blocked), the actor is returned to the pool and the conflict is reported back to the caller.
  - Spawn metadata captures the designated role or behavioural profile so downstream systems know how to treat the actor.
verification:
  - unit: provisioning a blueprint with multiple actor roles produces matching ledger entries and map occupancy.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F04_6 — Movement scheduling
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.PROPOSAL
priority: M
labels: [movement, scheduling, new]
rationale: The configurator must be able to advance dynamic actors along scripted paths while respecting the layered occupancy rules.
acceptance:
  - The manager maintains a movement script or queue per actor, derived from either the blueprint or strategic guidance.
  - Before issuing a move, the manager consults map enterability; only successful moves update the actor’s recorded position and ledger entry.
  - Movement outcomes (success or rejection with the reason) are logged so strategies can adapt or retry.
verification:
  - unit: executing a short movement script moves actors across enterable cells, rejects blocked cells, and records the outcome in the ledger/maps.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F04_7 — AIU catalog management
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.PROPOSAL
priority: M
labels: [aiu, catalog, new]
rationale: The configurator needs a registry of available actor intelligence units (AIUs) so it can select behaviours when provisioning dynamic actors.
acceptance:
  - The manager maintains a catalog of AIUs, including their identifiers and any fallback designations.
  - Public APIs allow tooling or strategic layers to register AIUs, query availability, and detect duplicates deterministically.
  - Requests for unknown AIUs return a documented fallback signal so downstream systems can respond predictably.
verification:
  - unit: registering, querying, and re-registering AIUs updates the catalog as expected and surfaces duplicate registrations.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F04_8 — AIU injection during provisioning
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.PROPOSAL
priority: H
labels: [aiu, provisioning, new]
rationale: Dynamic actors must receive the correct intelligence unit when they are spawned so behaviour aligns with the strategic plan.
acceptance:
  - When provisioning an actor, the configurator assigns an AIU from the catalog and records the assignment alongside the actor ledger entry.
  - If the desired AIU is unavailable, the manager applies a documented fallback (such as an instinct module) and records the downgrade for audit.
  - Consumers can query which AIU is currently assigned to a given actor handle through the public API.
verification:
  - unit: provisioning actors assigns catalogued AIUs, falls back when necessary, and exposes the recorded assignment via API calls.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F04_9 — AIU prerequisites & budget enforcement
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.PROPOSAL
priority: H
labels: [aiu, prerequisites, budget]
rationale: AIU assignments must honour stamina thresholds, enhanced observation capabilities, and budget ledgers so scenarios remain deterministic and balanced.
acceptance:
  - The configurator records per-module prerequisites (minimum stamina, enhanced observation flags) via deterministic APIs and validates them before attaching an AIU to an actor.
  - AIU assignment fails with a logged rejection when prerequisites are unmet or the budget ledger lacks sufficient points; successful assignments debit base and upkeep costs.
  - Reassignment attempts respect existing loadouts—failed prerequisite checks leave current AIUs intact while emitting diagnostics for audit.
verification:
  - unit: targeted tests demonstrate prerequisite enforcement by rejecting low-stamina actors, accepting actors once thresholds are met, and ensuring existing AIUs remain when new attachments fail.
  - integration: configurator ledger snapshots reflect debited costs and prerequisite flags for actors provisioned with `find_exit`, `defend_exit`, `patrol_corridor`, and `cultivation` modules.
traces:
  code: [apps/simulation/assembly/configurator/configurator.ts, apps/simulation/assembly/configurator/aiuRuntime.ts]
  tests: [apps/simulation/tests/P3_F04_aiuPrerequisites.test.js]

## P2-F10 — ACTOR POOLING (dynamic actors)
status: META
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.ACTOR
priority: H
labels: [actors, pooling, new]
rationale: Dynamic actors are managed separately from surfaces so their lifecycle and placement can be controlled precisely.
acceptance:
  - The actor pool exposes allocate, borrow, return, spawn, and despawn operations that integrate with the level map.
  - The pool enforces one-actor-per-cell by consulting enterability before spawn or move.
  - Child requirements (P2-F10_1+) define borrow/return semantics and placement rules.
verification:
  - review: pool API and tests confirm safe lifecycle and single-occupant enforcement.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F10_1 — Borrow/return semantics
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.ACTOR
priority: M
labels: [lifecycle, new]
rationale: Actors are reused efficiently without leaking handles.
acceptance:
  - Borrowing provides an available actor handle; returning makes it eligible for reuse.
  - Returned actors are reset to a neutral state.
verification:
  - unit: repeated borrow/return cycles reuse actors without cross-contamination.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F10_2 — Placement rules
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.ACTOR
priority: M
labels: [placement, rules, new]
rationale: Actors should only appear in valid locations.
acceptance:
  - Spawning or moving an actor requires a positive enterability check for the target cell.
verification:
  - unit: attempts to spawn into blocked or occupied cells are rejected.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F10_3 — Occupancy enforcement
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.ACTOR
priority: M
labels: [occupancy, enforcement, new]
rationale: Two actors should not occupy the same cell simultaneously.
acceptance:
  - The actor layer enforces one-actor-per-cell during spawns and moves.
verification:
  - unit: conflicting actor placements are rejected and logged.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F09 — DIRECTOR DIRECTIVE INTAKE (integration contract)
status: META
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.DIRECTOR
priority: M
labels: [director, directives, integration, updated]
rationale: The configurator must receive, validate, and archive directives produced by the director so they can be applied during planning without re-running higher-order intelligence inside the configurator states.
acceptance:
  - Director directives arrive through a structured contract that captures directive id, prompt summary, payload, and confidence metadata supplied by the director.
  - The configurator persists directive metadata (including provenance hashes and timestamps) alongside the planning ledger so downstream personas and Moderator logs can audit which directive influenced a change.
  - The configurator does not call external AI or solver services on behalf of the director; it simply accepts the directive and prepares it for downstream verification/application phases.
  - Child requirements (P2-F09_1+) define schema enforcement and directive application safeguards.
verification:
  - review: interface walkthrough demonstrates ingestion of a sample directive and the resulting provenance records inside configurator state.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F09_1 — Directive payload validation
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.DIRECTOR
priority: M
labels: [director, validation]
rationale: Incoming director directives must be schema-validated before they influence the environment so that malformed payloads cannot corrupt planning state.
acceptance:
  - Payloads are validated against a deterministic schema (theme, hazard emphasis, actor density, etc.) before they are staged for planning.
  - Validation results (success/failure, reason) are logged and stored with directive metadata for audit.
  - When validation fails, the configurator keeps the lifecycle running by recording the failure and falling back to the last confirmed directive.
verification:
  - unit: simulated directives with valid/invalid payloads confirm schema enforcement and failure logging.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F09_2 — Directive application
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.PLAN
priority: M
labels: [director, planning]
rationale: Validated director directives must translate into concrete adjustments to the layout plan while preserving hard constraints.
acceptance:
  - The configurator converts accepted directives into plan modifications such as adjusted room themes, trap placements, or adversary distributions.
  - Directives are validated against solvability, resource budgets, and policy rules before they reach the proposal phase.
  - Solver verification guarantees each generated layout satisfies playability requirements (e.g., a valid start-to-finish path) while honoring the directive’s thematic and hazard constraints.
  - Rejected directives trigger logging and fallback to a baseline plan so the lifecycle continues.
verification:
  - unit: applying sample directives confirms that valid directives update the plan, produce solver-certified paths, and invalid ones are rejected with recorded reasons.
traces:
  code: [apps/simulation/assembly/configurator/configuration-manager.ts]

## P2-F11 — MOVEMENT DISPATCH QUEUE (per-tick intent staging)
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.ACTOR
priority: H
labels: [movement, scheduling, aiu, fallback]
rationale: The configurator must coordinate ambulatory actors by staging their planned moves each tick before applying them.
acceptance:
  - The configurator exposes a `configurator_dispatch_process(handle)` entry point that materialises a per-tick queue for every ambulatory actor and returns a handle whose state can be inspected through `configurator_dispatch_get_*` accessors (count, actor handle, tier used, dx/dy intent, rejection reason, history records).
  - Each queue entry records the actor handle, originating cell snapshot (x, y, level), stamina at dispatch time, chosen intent vector, applied tier, and rejection message (empty when accepted) so downstream systems can audit behaviour.
  - Decision tiers execute in strict order: (1) AIU assignment tied to the actor, (2) logic persona fallback, (3) instinct fallback; once a tier produces an intent the lower tiers are skipped but the selected tier is logged.
  - Each actor’s intent is resolved independently using its own ledger placement, observations, and evaluation surface map; actors sharing a directive or AIU may still select different moves when their local context diverges.
  - Every ambulatory actor in the current viewport is assigned a deterministic per-tick priority token (e.g., RNG seeded by tick + handle); the queue is sorted lowest token first, with actor handle as a tie-breaker, guaranteeing fair, reproducible ordering even when actors cannot sense each other.
  - Dispatch resolves before the configurator’s Verify/Confirm phases and is the sole source of movement order handed to actors, ensuring enterability and stamina checks occur against the staged queue rather than ad-hoc calls.
  - The configurator signals actors according to queue order (e.g., via exposed lifecycle/contract calls) so actors only act when granted their slot and may apply their own internal logic within that window.
verification:
  - unit/integration: a fixture with multiple actors exercises the dispatch APIs, demonstrates tier escalation, validates queue ordering randomness/tie-breaks, and confirms accepted vs. rejected intents are applied consistently.
traces:
  code: [apps/simulation/assembly/configurator/states/dispatch.ts, apps/simulation/assembly/configurator/configurator.ts, apps/simulation/tests/P2_F11_dispatch.test.js]

## P2-F11_6 — Cultivation intent handling
status: proposed
owner: system
req_type: FUNCTIONAL
phase: runtime
area: CONFIGURATOR.DISPATCH
priority: H
labels: [aiu, cultivation, dispatch]
rationale: When actors enter cultivation, the configurator must stage zero-movement intents, allow vitals regeneration, and emit vulnerability windows for downstream enforcement.
acceptance:
  - The dispatch queue records cultivation intents with zero deltas and tier AIU.
  - Cultivation metadata (ticks accumulated) is stored so the coordinator can enforce post-cultivation vulnerability.
  - Actors in cultivation regenerate vitals while queued; no stamina cost is applied.
  - Telemetry emitted by the configurator includes cultivation status and ticks accrued per actor.
verification:
  - unit: enqueue cultivation intents and assert zero movement with metadata preserved.
  - integration: coordinator resolve/apply phases observe vulnerability data and keep actors stationary during cultivation.
traces:
  code: []
