## P4-F01 — INTROSPECTION (resource awareness)
status: META
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.SELF
priority: H
labels: [introspection, self-awareness]
rationale: The agent must expose its core resource pillars so other domains can reason about capability and cost.
acceptance:
  - The agent maintains self-state for each resource pillar (Stamina, Durability, Health, Mana) with current, max, and regen values.
  - The agent clearly distinguishes static items from mobile agents via these resource configurations.
  - Resource profiles convey occupancy semantics: static walkable tiles expose Durability (D_C/D_M/D_R) as ∞ while Stamina, Health, and Mana triples remain 0; blocking entities expose finite Durability and non-zero resource ranges.
verification:
  - unit: reading self-state returns expected resource records for static and mobile archetypes.
traces:
  code: [assembly/agent/agent.ts]

## P4-F01_1 — resource snapshot: stamina
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.SELF
priority: H
labels: [introspection, stamina]
rationale: Movement logic depends on stamina availability.
acceptance:
  - The agent tracks Stamina current (S_C), max (S_M), and tick regen (S_R).
  - Static items report S_M = S_C = S_R = 0. Mobile agents report finite S_M, S_C within [0, S_M], and S_R within a finite range.
verification:
  - unit: static and mobile initializations expose the expected stamina triple through introspection getters.
traces:
  code: [assembly/agent/agent.ts]

## P4-F01_2 — resource snapshot: durability
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.SELF
priority: H
labels: [introspection, durability]
rationale: Durability represents structural integrity for obstacles and agents.
acceptance:
  - The agent tracks Durability current (D_C), max (D_M), and tick regen (D_R).
  - Static items report D_M = D_C = D_R = ∞ (or a sentinel representing an unbreakable state). Mobile agents report finite, non-zero values.
verification:
  - unit: introspection exposes durability values consistent with static vs. mobile presets.
traces:
  code: [assembly/agent/agent.ts]

## P4-F01_3 — resource snapshot: health
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.SELF
priority: H
labels: [introspection, health]
rationale: Combat and survival systems require access to health data.
acceptance:
  - The agent tracks Health current (H_C), max (H_M), and tick regen (H_R).
  - Static items report H_M = H_C = H_R = 0. Mobile agents report finite, non-zero values with H_C within [0, H_M].
verification:
  - unit: introspection exposes health triples per classification.
traces:
  code: [assembly/agent/agent.ts]

## P4-F01_4 — resource snapshot: mana
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.SELF
priority: H
labels: [introspection, mana]
rationale: Magical or energy-based behaviours require mana availability.
acceptance:
  - The agent tracks Mana current (MN_C), max (MN_M), and tick regen (MN_R).
  - Static items report MN_M = MN_C = MN_R = 0. Mobile agents report finite, non-zero values within defined ranges.
verification:
  - unit: introspection exposes mana values matching the configured archetype.
traces:
  code: [assembly/agent/agent.ts]

## P4-F01_5 — understanding of location and surrounding
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.SELF
priority: H
labels: [introspection, mana]
rationale: Agents need to have an up to date understanding of if other agents are surrounding them.
acceptance:
  - The agent, through interrogation and observation maintains a model of what other agents are sourounding them.
  - The model is maintained for the current 2 dimensional plane It does not have information of different levels.
verification:
  - unit: agent populates and maintains a environmental awareness model by interogating its surroundings
traces:
  code: [assembly/agent/agent.ts]

## P4-F01_6 — stable agent identity
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.SELF
priority: H
labels: [introspection, identity]
rationale: Other domains need a durable identifier to correlate events and traces for the same agent instance.
acceptance:
  - When an agent context is first introspected, the agent derives a deterministic, non-zero identity value from its lifecycle handle.
  - The identity remains stable across ticks and lifecycle re-initialisations for the same handle; repeated calls return the same value until the agent is destroyed.
  - The identity getter is available to other domains so observations, emissions, and control surfaces can reference the correct agent.
verification:
  - unit: create an agent, read its identity before and after lifecycle init/step, destroy and create a new agent, and confirm identities remain stable per handle and unique across handles.
traces:
  code: [assembly/agent/introspection.ts, assembly/agent/agent.ts]

## P4-F01_7 — position snapshot: coordinates & level
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.SELF
priority: H
labels: [introspection, position]
rationale: Movement, observation, and emission workflows all depend on the authoritative position and level maintained by the agent.
acceptance:
  - Introspection exposes the agent's current X and Y coordinates from SelfState through getter functions.
  - Introspection exposes the agent's current level (vertical plane) through a getter that stays in sync with transitions.
  - A convenience getter returns the position as a Vec2 copy so callers can read location without mutating internal state.
  - After a transition mutates position or level, the introspection getters reflect the new values within the same tick.
verification:
  - unit: move an agent horizontally and vertically via transition helpers and verify the X, Y, level, and Vec2 getters return updated values while mutating the returned Vec2 leaves the internal state unchanged.
traces:
  code: [assembly/agent/introspection.ts, assembly/agent/agent.ts, assembly/agent/transition.ts]

## P4-F02 — OBSERVATION (sensing environment)
status: META 
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.OBS
priority: H
labels: [observation, perception]
rationale: The agent must be able to sense and interpret its environment and other agents nearby.
acceptance:
  - The agent gathers environment data within its defined range.
verification:
  - unit: injecting environment frames yields expected sensed data.
traces:
  code: [assembly/agent/agent.ts]

## P4-F02_1 — interrogating surroundings, no constraints
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.OBS
priority: H
labels: [observation, perception]
rationale: The agent can use messages to interrogate the squares immediately sourounding it.
acceptance:
  - The observing agent can only interrogate the surrounding squares by message passing the agents that compose them.
  - If no messages are returned the agent only has information that the surrounding agent didn't provide a response but no details on what the surrounding agent is.
  - If the surrounding agent responds, the observing agent can determine information about it based on the observing agent's capabilities.
  - The higher the capabilities of the observing agent, the more information they can gather.
verification:
  - unit: the agent can determine what occupies it's immediate surroundings through message passing. It can interrogate the cardinal and intercardinal directions.
traces:
  code: [assembly/agent/agent.ts]

## P4-F02_2 — structure of an observation
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.OBS
priority: H
labels: [observation, perception, memory]
rationale: The agent will capture observational information in a stuctured way in order to effectively use it for decision making.
acceptance:
  - All observations are gathered through interrogation.
  - An agent with basic observational capabilities will capture a basic fact on where it was when an observation was taken.
  - An agent with basic observational capabilities will capture a basic fact on where the agent it was observed when the observation was taken.
  - An agent with basic observational capabilities will capture a basic fact on the tick that the observation was recorded in.
  - An agent with basic observational capabilities agent will capture a basic fact on what it is observing. What comes in the context of the purpose of the agent it is observing. Is it observing a wall tile, a floor tile, or another ambulatory agent.
  - An agent with enhanced observational capabilities will capture complex facts that are not accessible through basic interrogation related to SelfState items such as vitals (health, stamina).
verification:
  - unit: An agent acting as a basic agent interrogates its surrounding agents and gathers basic information into an obvservation that it adds to observation item. An agent that is acting as an enhanced agent can collects additional information related to the SelfState of the agent it is observing and adds it to an observation item.
traces:
  code: [assembly/agent/agent.ts]

## P4-F02_3 — observational range and memory
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.OBS
priority: H
labels: [observation, perception, memory]
rationale: The agent needs the concept of observational memory so that it can make a decision based on multiple prioritized observations, sometimes taken across multiple ticks.
acceptance:
  - The agent maintains an observation queue that it can add or delete information received from its interrogation of surrounding agents.
  - The observation storage queue at a minimum contains the result of interrogating the agents in the direct proximity known as the observational radar (N,E,S,W,NE,NW,SE,SW).
  - Based on a user supplied parameter measured in ticks the observation queue can store a history of observations based on the previous location the agent occupied and what it observed through interrogation from surrounding agents when it was in that area.
  - Based on a supplied parameter it is posible to increase the range of the observational radar.
  - Older observations are lower down in the queue and are treated as less relivatent in decision making.
  - Other than age, observations are given a priority based on what it relates to. If an ambulatory agent is spotted within its observational radar.
verification:
  - unit: The agent can move, interrogate surrounding agents for information, add observations about those agents to its local observational state, and drop observations from its queue based on how many observations are allowed by the ticks parameter and its observational radar.
traces:
  code: [assembly/agent/agent.ts]

## P4-F03 — EVALUATION (cognition)
status: META
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.EVAL
priority: H
labels: [evaluation, cognition, decision-making]
rationale: The agent must decide actions using logic, planning, or strategy.
acceptance:
  - The agent produces a plan or next action based on available state and observations.
verification:
  - unit: given defined inputs, agent returns consistent decisions.
traces:
  code: [backend/assembly/runtime/controller.ts, backend/assembly/runtime/reasoner_bridge.ts]

## P4-F03_1 — basic movement decisions
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.EVAL
priority: H
labels: [evaluation, cognition, decision-making, where to move]
rationale: Based on the agent's observations about his environment. It can only choose to move to a valid location.
acceptance:
  - The agent lists moves that are valid and moves that are not.
  - The agent stores a list of where it can and can not move to each tick.
  - The agent takes the first valid move.
verification:
  - unit: create a grid of locations some that are not valid to move to. place the agent and evaluate where they can move to.
traces:
  code: []

## P4-F04 — TRANSITION (motor/actions)
status: META
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.TRANSITION
priority: H
labels: [transition, action, motor]
rationale: The agent must change its state or position predictably, applying decisions from introspection, observation, and evaluation.
acceptance:
  - The agent transitions between states or positions in accordance with decisions and constraints.
verification:
  - unit: invoking transitions results in predictable changes in state or position.
traces:
  code: [backend/assembly/runtime/agent.ts, backend/assembly/runtime/intent.ts]

## P4-F04_1 — unconstrained movement
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.TRANSITION
priority: H
labels: [transition, action, motor, movement]
rationale: The agent must be able to move in two dimensions x and y coordinates AND where the level design permits increase or decrease their current vertical level.
acceptance:
  - The agent is initialized with an x and y coorindate.
  - The agent moves from one x, y coordinate in a specified direction.
  - The agent can move up a level and down a level.
verification:
  - unit: invoking movement results in predictable changes in state or position.
traces:
  code: []

## P4-F04_2 — constrained movement (obstacles)
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.TRANSITION
priority: H
labels: [transition, action, motor, movement, obstacles]
rationale: The agent can move in directions that are not occupied by other agents whether they are static, like an obstacle, or ambulatory.
acceptance:
  - The agent can move to unoccupied agent tiles that have the purpose of floor tiles.
  - The agent can't pass through stationary agents like walls or obstacles.
  - The agent can't pass through other ambulatory agents that are occuping a space that the agent has the ability to move to in an onconstrained state.
verification:
  - unit: invoking movement results in predictable changes in state or position.
traces:
  code: []

## P4-F04_3 — stamina reducing movement
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.TRANSITION
priority: H
labels: [transition, action, motor, movement, stamina]
rationale: The agent spends from its current resource pillar to change state. Movement consumes current stamina.
acceptance:
  - If the agent wishes to move, they consume a fraction of their current stamina.
  - The agent can only move if they have stamina.
  - Stamina cost is based on a percentage of maximum staminia. 
  - Moving in the cardinal directions consumes a standard percent of stamina (based on percentage of total.)
  - Moving in the inter-cardinal directions consumes √2 x the standard percent of stamina.
  - Moving down a level uses √3 x the standard percentage of stamina.
verification:
  - unit: invoking one or more agents with some current staminia, move them around by changing their x, y, and level, ensure that the appropraite amount of stamina is used based on type of movement, ensure that an agent that does not have enough stamina can not make the requested movement.
traces:
  code: []

## P4-F05 — EMISSION (communication)
status: META
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.EMMIS
priority: M
labels: [emission, communication]
rationale: The agent must emit signals to its environment that can be observed by other agents.
acceptance:
  - The agent emits messages or signals that are detectable by agents in proximity.
verification:
  - unit: one agent emits, another agent ingests the message.
traces:
  code: [backend/assembly/runtime/emission.ts]

## P4-F05_1 — simple message passing
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.IMMIS
priority: M
labels: [emission, communication, message passing]
rationale: The agents both pooled and individual need to pass information between other agents in their proximity.
acceptance:
  - A message can be passed from agent to agent within a defined radius.
  - Agents outside of the radius can't easdrop on a message.
  - The message queue has a limited size with the oldest messages dropping when it reaches the end of its queue.
  - Each agent gets a "read receipt" when another agent has read its message.
  - Messages can result in agent action.
  - The basic information that all agents MUST provide on interrogation is their current location (x,y,level) and the locations of all sounding agents if they exist.
  - If a tile does not have any tiles surrounding them in the cardnal or inter-cardinal directions it responds with no information for that location.
verification:
  - unit: one agent emits, another agent ingests the message.
traces:
  code: [backend/assembly/runtime/emission.ts]

## P4-F05_2 — actions based on requests, no contraints
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.EMMIS
priority: M
labels: [emission, communication, message passing]
rationale: One agent can pass messages along to another agent and request information about it. This is a form of local gossip network.
acceptance:
  - Agents can respond to an interrogation message.
  - Agents can send basic information about themselves to the interrogating party.
verification:
  - unit: one agent sends a request to another agent using a specific message type, the the agent receiving the request sends information about itself to the requesting agent.
traces:
  code: [backend/assembly/runtime/emission.ts]

## P4-N06 — AGENT STATEFLOW (design intent)
status: META
owner: system
req_type: NON_FUNCTIONAL
phase: runtime
area: AGENT.ARCH
priority: H
labels: [design, architecture, orchestration]
rationale: The agent’s internal behavior should follow a clear and consistent cycle of states, with each state focusing on a specific aspect of the agent’s role. This keeps the design understandable, testable, and extensible.
acceptance:
  - The agent’s top-level cycle follows a predictable order: introspection, observation, evaluation, transition, emission.
  - Each state is responsible only for its own concerns (e.g., self-awareness, sensing, decision-making, acting, communicating).
  - The top-level cycle ensures the agent produces at most one action per tick and exposes its reasoning through observable events.
verification:
  - design review confirms that each functional module aligns with its corresponding top-level requirement (P4-F01 to P4-F05).
  - integration tests confirm that the cycle runs in the intended order and does not produce more than one action per tick.
traces:
  code: [backend/assembly/runtime/agent_fsm.ts]


## P4-N07_1 - configuration agents up to purpose
status: active
owner: system
req_type: NON_FUNCTIONAL
phase: runtime
area: AGENT.ARCH
priority: H
labels: [agent configuration]
rationale: The system must support the ability to configure agents according to purpose.
acceptance:
  - The system must allow for configuing agents on creation including setting of selfState attributes.
verification:
  - Agents are created with multiple different configurations and checked to see if they hold the appropriate configuration after creation.
traces:
  code: []

## P4-N08 — AGENT POOLING (deployment strategy)
status: META
owner: system
req_type: NON_FUNCTIONAL
phase: runtime
area: AGENT.ARCH
priority: H
labels: [pooling, scalability, deployment]
rationale: The platform must support many agents at once by grouping simple agents together while letting advanced agents run independently. This keeps performance predictable for everyday crowds and leaves room for richer behaviour where it matters. Everything in the game is an agent. They have different levels of invested intellect. Walls and floor-tiles are agents, but they are not ambulatory and don't have any intelligence. A boss does have intelligence and operates as a distince agent with it's own lifecycle and state.
acceptance:
  - The system can host large numbers of lightweight agents without exhausting a single thread.
  - More capable agents are able to run without being slowed down by the pooled group.
  - Each agent can be created, tracked, and removed individually, regardless of which execution style it uses.
verification:
  - design review confirms that pooling and individual execution paths coexist and cover all agent types.
  - performance tests demonstrate that adding pooled agents does not delay the specialised agents beyond agreed limits.
traces:
  code: []

## P4-N08_1 — pooled simple agents
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.ARCH
priority: H
labels: [pooling, scalability, simpletons]
rationale: Most agents are basic “simpletons” that only need the shared worker. They must be able to communicate and update in that shared space without stepping on each other. Examples of simpleton agents are walls and floor tiles.
acceptance:
  - Simple agents can join a shared pool and run on the same thread without blocking the interface.
  - The pool processes each member in order and keeps their state separate.
  - Messages or nudges that belong to one pooled agent do not leak into another.
verification:
  - unit: create several pooled agents and confirm they each retain independent positions and status through multiple ticks.
  - performance: measure a large batch of pooled agents and confirm frame time stays within budget.
traces:
  code: []

## P4-N08_2 — dedicated specialists
status: active
owner: system
req_type: FUNCTIONAL
phase: runtime
area: AGENT.ARCH
priority: H
labels: [workers, specialists, isolation]
rationale: “Intellectual” agents need their own worker threads so they can plan, sense, and react without delays from the crowd.
acceptance:
  - An intellectual agent can start in its own worker and keep running even if the pooled group is busy.
  - The system only introduces a connection between intellectuals when they come close enough to interact.
  - When an intellectual agent ends, its worker releases resources and the agent is removed cleanly.
verification:
  - integration: run an intellectual agent alongside a busy pool and confirm its tick timing stays within its limit.
  - unit: place intellectual agents far apart, then bring them together and confirm proximity triggers communication while distance breaks it again.
traces:
  code: []

## P4-N09 — resource snapshot encoding (stamina/health/mana pillars)
status: draft
owner: system
req_type: NON_FUNCTIONAL
phase: runtime
area: AGENT.SELF
priority: H
labels: [introspection, encoding, bitpack]
rationale: Pillar snapshots must serialize into compact 32-bit words while preserving large maxima and percentage-based current/regen rates.
acceptance:
  - Each pillar is encoded as a single little-endian u32 with layout:
      * bits 31..20: max_mantissa (12-bit unsigned)
      * bits 19..16: max_exponent (4-bit unsigned)
      * bits 15..8 : current_percent (8-bit unsigned) where current = round(max * current_percent / 255)
      * bits 7..0  : regen payload; bit7 is sign (0 = regen, 1 = degeneration), bits 6..0 magnitude where |regen| = round(max * magnitude / 127) per tick.
  - max is reconstructed as (max_mantissa << max_exponent); implementations must treat max_mantissa = 0 as max = 0 regardless of exponent.
  - Encoding clamps inputs so current stays within [0, max] and regen magnitude reflects a percentage ≤ 100% of max per tick.
  - Agents decoding the word reproduce the same max/current/regen values (within one rounding unit) used during encoding.
verification:
  - unit: round-trip tests encode known (max, current, regen) tuples into the 32-bit format, then decode and assert max/current/regen match expected integer results and rounding behaviour.
  - unit: boundary tests cover exponent saturation, zero/negative regen, and full depletion/recovery percentages.
traces:
  code: [backend/schemas/agent-schema.json, assembly/agent/contracts.ts (future encode/decode helpers)]

## P4-N10 — ORCHESTRATION
status: active
owner: system
req_type: NON_FUNCTIONAL
phase: runtime
area: AGENT.ORCH
priority: H
labels: [agent pool, movement, decision making, observation]
rationale: Test the implementation of all the agent functionality by create a group of agents and having them navigate around a surface of agent tiles and interact with obstacles and each other to create a visual map of a level
acceptance:
  - Multiple agenst created.
  - Static agents created as pooled agents.
  - Ambulatory agents created as dedicated specialists
  - Test run across multiple ticks.
  - Specialist agents move each tick.
  - Specialist agents observe stamina drain on each movement according to movement type
  - A visual map is created from the observations of the agent-space as specialists move around the space.
verification:
  - integration: run the entire simulation across multiple ticks, ensure all supporting functionality behaves as expected.
traces:
  code: []


---

## Appendix — Notes
- P4-N06 provides architectural guidance: it establishes that the top-level agent FSM orchestrates the functional umbrellas P4-F01 through P4-F05.
- Each functional area (INTROSPECTION, OBSERVATION, EVALUATION, TRANSITION, EMISSION) is realized as a domain-specific state machine under this cycle.
- P4-N06 is non-functional: it describes design intent, not specific implementation details.

## Appendix — Field Intent
This appendix explains the purpose of each field in the requirement entries, to help maintain clarity and consistency across requirements.

- **status:** Lifecycle or maturity of the requirement (e.g., META, active, draft). Indicates whether the requirement is guiding principle, implemented, or under development.
- **owner:** Who is accountable for the requirement (e.g., system, team, persona). Helps trace responsibility for changes or clarifications.
- **req_type:** Classification of the requirement, usually **FUNCTIONAL** (what the system must do) or **NON_FUNCTIONAL** (quality attributes, constraints, design intent).
- **phase:** The stage of the lifecycle where the requirement applies (e.g., runtime, compile-time, design).
- **area:** Subsystem or domain the requirement belongs to (e.g., AGENT.SELF, AGENT.OBS, AGENT.EVAL).
- **priority:** Relative importance of the requirement (e.g., H = high, M = medium, L = low). Guides implementation and testing order.
- **labels:** Keywords to categorize and quickly search/filter requirements (e.g., introspection, stamina, pooling).
- **rationale:** The “why” of the requirement — justification for its existence and the problem it addresses.
- **acceptance:** Conditions of satisfaction. What must be true for the requirement to be considered fulfilled. Written in outcome-focused terms.
- **verification:** The “how” of testing or proving the acceptance criteria. May include unit, integration, design review, or performance testing methods.
- **traces:** References to implementation artifacts (e.g., code files, modules) that realize this requirement. Supports traceability from requirement to code/tests.
