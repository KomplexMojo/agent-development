## P5-F01 — COORDINATOR (simulation conductor)
status: META
owner: system
req_type: FUNCTIONAL
phase: runtime
area: COORDINATOR
priority: H
labels: [coordinator, lifecycle, scheduling]
rationale: A dedicated coordinator persona coordinates the per-tick execution order across Director, Configurator, Actor, and Moderator so complex interactions resolve deterministically.
acceptance:
  - The coordinator exposes `coordinator_lifecycle_*` entry points consistent with other personas.
  - Per tick, the coordinator drives personas through a defined sequence (e.g., Director → Configurator → Actor → Moderator).
  - The coordinator tracks tick metadata (tick index, seed, timing) for audit and telemetry.
verification:
  - unit/integration: lifecycle smoke test demonstrates one tick through the scheduled sequence without dropping events.
traces:
  code: []

## P5-F02 — COORDINATOR STATES (lifecycle phases)
status: META
owner: system
req_type: FUNCTIONAL
phase: runtime
area: COORDINATOR
priority: M
labels: [coordinator, state-machine]
rationale: Coordinator behaviour is realized as a state machine (e.g., Schedule, Resolve, Commit) so coordination logic remains modular and testable.
acceptance:
  - State handlers live under `apps/simulation/assembly/coordinator/states/*` and operate on shared context defined in `contracts.ts`.
  - States include at minimum: Schedule (collect intents/requests), Resolve (apply conflict rules), Commit (dispatch results and telemetry).
  - Schedule waits for the configurator’s dispatch queue to finish staging moves, then hands actors permits strictly in the order defined by that queue before Resolve applies conflict rules.
  - Resolve consults the staged intents and applies them independently per actor; outcomes are tracked per actor so Commit can record distinct positions/telemetry even when actors share the same directive tier.
  - States may invoke other personas via explicit contracts but never mutate their internal state directly.
verification:
  - unit: state-level tests confirm scheduling, resolution, and commit phases manipulate coordinator context as expected.
traces:
  code: []

## P5-F03 — COORDINATOR TELEMETRY (moderator integration)
status: META
owner: system
req_type: FUNCTIONAL
phase: runtime
area: COORDINATOR
priority: M
labels: [coordinator, telemetry]
rationale: The coordinator supplies Moderator with tick-level summaries so observers can replay interactions.
acceptance:
  - Each tick produces a structured summary (tick id, participants involved, conflicts resolved, final intents applied).
  - Summaries capture the configurator dispatch ordering (actor handles, tiers used, rejection reasons) so Moderator logs can replay movement sequencing.
  - Summaries are handed to Moderator through a defined contract before Moderator emits artifacts.
verification:
  - unit/integration: simulated ticks produce expected orchestration summaries visible in Moderator logs.
traces:
  code: []

## P5-F04 — Cultivation vulnerability enforcement
status: proposed
owner: system
req_type: FUNCTIONAL
phase: runtime
area: COORDINATOR
priority: H
labels: [coordinator, cultivation, vulnerability]
rationale: After cultivation, actors are vulnerable for ⌈√ticks⟩ ticks. The coordinator must track cultivation duration and reject attack/defend intents until the vulnerability window expires.
acceptance:
  - Resolve state reads cultivation metadata from the configurator queue and tracks each actor’s vulnerability countdown.
  - While vulnerability > 0, offensive/defensive intents are downgraded to wait (or rejected) and telemetry records the override.
  - Vulnerability counters decrement per tick and reset when actors successfully perform a non-cultivation action.
verification:
  - unit: simulated ticks show an actor cultivating for N ticks then being blocked from attack/defend for ⌈√N⌉ ticks.
  - integration: moderator summaries include vulnerability enforcement events for auditing.
traces:
  code: []
